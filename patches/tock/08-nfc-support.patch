commit f8bbc856bfa5b3ab258c242de59c8ed976887aad
Author: Kamran Khan <kamranrkhan@google.com>
Date:   Fri Mar 26 14:33:35 2021 -0700

    Apply OpenSK patch 08-nfc-support

diff --git a/Cargo.toml b/Cargo.toml
index cfd63b117..83c48558e 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -13,8 +13,6 @@ members = [
     "boards/msp_exp432p401r",
     "boards/nordic/nrf52840dk",
     "boards/nordic/nrf52840_dongle",
-    "boards/nordic/nrf52840_dongle_dfu",
-    "boards/nordic/nrf52840_mdk_dfu",
     "boards/nordic/nrf52dk",
     "boards/nucleo_f429zi",
     "boards/nucleo_f446re",
diff --git a/boards/components/src/lib.rs b/boards/components/src/lib.rs
index 520408fcb..5e4f330aa 100644
--- a/boards/components/src/lib.rs
+++ b/boards/components/src/lib.rs
@@ -23,6 +23,7 @@ pub mod lldb;
 pub mod lsm303dlhc;
 pub mod mlx90614;
 pub mod mx25r6435f;
+pub mod nfc;
 pub mod ninedof;
 pub mod nonvolatile_storage;
 pub mod nrf51822;
diff --git a/boards/components/src/nfc.rs b/boards/components/src/nfc.rs
new file mode 100644
index 000000000..bd480eaa6
--- /dev/null
+++ b/boards/components/src/nfc.rs
@@ -0,0 +1,59 @@
+//! Component for NFC Tag.
+//!
+//! Usage
+//! -----
+//! ```rust
+//! let nfct = components::nfct::NfcComponent::new(board_kernel, &nrf52840::nfct::NFCT).finalize(());
+//! ```
+
+// Author: Mirna Al-Shetairy <mshetairy@google.com>
+
+use capsules::nfc;
+use kernel::capabilities;
+use kernel::component::Component;
+use kernel::create_capability;
+use kernel::hil::nfc::NfcTag;
+use kernel::static_init;
+
+pub struct NfcComponent {
+    board_kernel: &'static kernel::Kernel,
+    nfct: &'static dyn NfcTag<'static>,
+}
+
+impl NfcComponent {
+    pub fn new(
+        board_kernel: &'static kernel::Kernel,
+        nfct: &'static dyn NfcTag<'static>,
+    ) -> NfcComponent {
+        NfcComponent {
+            board_kernel: board_kernel,
+            nfct: nfct,
+        }
+    }
+}
+
+impl Component for NfcComponent {
+    type StaticInput = ();
+    type Output = &'static nfc::NfcDriver<'static>;
+
+    unsafe fn finalize(self, _static_buffer: Self::StaticInput) -> Self::Output {
+        let grant_cap = create_capability!(capabilities::MemoryAllocationCapability);
+
+        let tx_buffer = static_init!([u8; nfc::MAX_LENGTH], [0u8; nfc::MAX_LENGTH]);
+        let rx_buffer = static_init!([u8; nfc::MAX_LENGTH], [0u8; nfc::MAX_LENGTH]);
+
+        let nfct = static_init!(
+            // Supply to the capsule: the driver and a grant
+            nfc::NfcDriver<'static>,
+            nfc::NfcDriver::new(
+                self.nfct,
+                tx_buffer,
+                rx_buffer,
+                self.board_kernel.create_grant(&grant_cap)
+            )
+        );
+        self.nfct.set_client(nfct);
+        self.nfct.enable();
+        nfct
+    }
+}
diff --git a/boards/nordic/nrf52840dk/src/main.rs b/boards/nordic/nrf52840dk/src/main.rs
index c17b42a84..430b5a310 100644
--- a/boards/nordic/nrf52840dk/src/main.rs
+++ b/boards/nordic/nrf52840dk/src/main.rs
@@ -174,6 +174,7 @@ pub struct Platform {
         capsules::virtual_alarm::VirtualMuxAlarm<'static, nrf52840::rtc::Rtc<'static>>,
     >,
     nonvolatile_storage: &'static capsules::nonvolatile_storage_driver::NonvolatileStorage<'static>,
+    nfc: &'static capsules::nfc::NfcDriver<'static>,
     nvmc: &'static nrf52840::nvmc::SyscallDriver,
     usb: &'static capsules::usb::usb_ctap::CtapUsbSyscallDriver<
         'static,
@@ -200,6 +201,7 @@ impl kernel::Platform for Platform {
             capsules::temperature::DRIVER_NUM => f(Some(self.temp)),
             capsules::analog_comparator::DRIVER_NUM => f(Some(self.analog_comparator)),
             capsules::nonvolatile_storage_driver::DRIVER_NUM => f(Some(self.nonvolatile_storage)),
+            capsules::nfc::DRIVER_NUM => f(Some(self.nfc)),
             nrf52840::nvmc::DRIVER_NUM => f(Some(self.nvmc)),
             capsules::usb::usb_ctap::DRIVER_NUM => f(Some(self.usb)),
             capsules::firmware_protection::DRIVER_NUM => f(Some(self.crp)),
@@ -386,6 +388,9 @@ pub unsafe fn reset_handler() {
         nrf52_components::BLEComponent::new(board_kernel, &nrf52840::ble_radio::RADIO, mux_alarm)
             .finalize(());
 
+    let nfc_driver =
+        components::nfc::NfcComponent::new(board_kernel, &nrf52840::nfct::NFCT).finalize(());
+
     let (ieee802154_radio, _mux_mac) = components::ieee802154::Ieee802154Component::new(
         board_kernel,
         &nrf52840::ieee802154_radio::RADIO,
@@ -507,6 +512,7 @@ pub unsafe fn reset_handler() {
         nonvolatile_storage,
         nvmc,
         usb,
+        nfc: nfc_driver,
         crp,
         ipc: kernel::ipc::IPC::new(board_kernel, &memory_allocation_capability),
     };
diff --git a/capsules/src/driver.rs b/capsules/src/driver.rs
index f536dad32..9702cba47 100644
--- a/capsules/src/driver.rs
+++ b/capsules/src/driver.rs
@@ -33,6 +33,7 @@ pub enum NUM {
     BleAdvertising        = 0x30000,
     Ieee802154            = 0x30001,
     Udp                   = 0x30002,
+    NFC                   = 0x30003,
 
     // Cryptography
     Rng                   = 0x40001,
diff --git a/capsules/src/lib.rs b/capsules/src/lib.rs
index 7538aad18..b3338b330 100644
--- a/capsules/src/lib.rs
+++ b/capsules/src/lib.rs
@@ -46,6 +46,7 @@ pub mod max17205;
 pub mod mcp230xx;
 pub mod mlx90614;
 pub mod mx25r6435f;
+pub mod nfc;
 pub mod ninedof;
 pub mod nonvolatile_storage_driver;
 pub mod nonvolatile_to_pages;
diff --git a/capsules/src/nfc.rs b/capsules/src/nfc.rs
new file mode 100644
index 000000000..617992244
--- /dev/null
+++ b/capsules/src/nfc.rs
@@ -0,0 +1,340 @@
+use core::cell::Cell;
+use core::cmp;
+use kernel::common::cells::{OptionalCell, TakeCell};
+use kernel::debug;
+use kernel::hil::nfc;
+use kernel::{AppId, AppSlice, Callback, Driver, Grant, ReturnCode, Shared};
+
+/// Syscall driver number.
+use crate::driver;
+pub const DRIVER_NUM: usize = driver::NUM::NFC as usize;
+
+#[derive(Default)]
+pub struct App {
+    tx_callback: Option<Callback>,
+    tx_buffer: Option<AppSlice<Shared, u8>>,
+    rx_callback: Option<Callback>,
+    rx_buffer: Option<AppSlice<Shared, u8>>,
+}
+
+pub const MAX_LENGTH: usize = 256;
+
+pub struct NfcDriver<'a> {
+    driver: &'a dyn nfc::NfcTag<'a>,
+    application: Grant<App>,
+    tx_in_progress: OptionalCell<AppId>,
+    tx_buffer: TakeCell<'static, [u8]>,
+    rx_in_progress: OptionalCell<AppId>,
+    rx_buffer: TakeCell<'static, [u8]>,
+    driver_selected: Cell<bool>,
+    tag_configured: Cell<bool>,
+    current_field: Cell<nfc::NfcFieldState>,
+}
+
+impl<'a> NfcDriver<'a> {
+    pub fn new(
+        driver: &'a dyn nfc::NfcTag<'a>,
+        tx_buffer: &'static mut [u8; MAX_LENGTH],
+        rx_buffer: &'static mut [u8; MAX_LENGTH],
+        grant: Grant<App>,
+    ) -> NfcDriver<'a> {
+        NfcDriver {
+            driver: driver,
+            application: grant,
+            tx_in_progress: OptionalCell::empty(),
+            tx_buffer: TakeCell::new(tx_buffer),
+            rx_in_progress: OptionalCell::empty(),
+            rx_buffer: TakeCell::new(rx_buffer),
+            driver_selected: Cell::new(false),
+            tag_configured: Cell::new(false),
+            current_field: Cell::new(nfc::NfcFieldState::None),
+        }
+    }
+
+    /// Helper function to reset the state of the capsule
+    fn reset(&self) {
+        self.driver_selected.set(false);
+        self.current_field.set(nfc::NfcFieldState::Off);
+        self.tag_configured.set(false);
+    }
+
+    /// Internal helper function for setting up frame transmission
+    fn transmit_new(&self, app_id: AppId, app: &mut App, len: usize) -> ReturnCode {
+        if self.current_field.get() != nfc::NfcFieldState::On {
+            return ReturnCode::ECANCEL;
+        }
+        // Driver not ready yet
+        if !self.driver_selected.get() {
+            return ReturnCode::EOFF;
+        }
+        match app.tx_buffer.take() {
+            Some(slice) => self.transmit(app_id, app, slice, len),
+            None => ReturnCode::EBUSY,
+        }
+    }
+
+    /// Internal helper function for data transmission
+    fn transmit(
+        &self,
+        app_id: AppId,
+        app: &mut App,
+        slice: AppSlice<Shared, u8>,
+        len: usize,
+    ) -> ReturnCode {
+        if self.tx_in_progress.is_none() {
+            self.tx_in_progress.set(app_id);
+            self.tx_buffer
+                .take()
+                .map(|buffer| {
+                    for (i, c) in slice.as_ref().iter().enumerate() {
+                        buffer[i] = *c;
+                    }
+                    let result = self.driver.transmit_buffer(buffer, len);
+                    if result.is_err() {
+                        let (err, buf) = result.unwrap_err();
+                        self.tx_buffer.replace(buf);
+                        return err;
+                    }
+                    ReturnCode::SUCCESS
+                })
+                .unwrap()
+        } else {
+            app.tx_buffer = Some(slice);
+            ReturnCode::EBUSY
+        }
+    }
+
+    /// Internal helper function for starting a receive operation
+    fn receive_new(&self, app_id: AppId, app: &mut App, _len: usize) -> ReturnCode {
+        if !self.tag_configured.get() {
+            return ReturnCode::EOFF;
+        }
+        if self.current_field.get() != nfc::NfcFieldState::On {
+            return ReturnCode::ECANCEL;
+        }
+        // Driver not ready yet
+        if !self.driver_selected.get() | self.rx_buffer.is_none() {
+            return ReturnCode::EBUSY;
+        }
+        if app.rx_buffer.is_some() {
+            self.rx_buffer
+                .take()
+                .map(|buffer| {
+                    self.rx_in_progress.set(app_id);
+                    let result = self.driver.receive_buffer(buffer);
+                    if result.is_err() {
+                        let (err, buf) = result.unwrap_err();
+                        self.rx_buffer.replace(buf);
+                        return err;
+                    }
+                    ReturnCode::SUCCESS
+                })
+                .unwrap()
+        } else {
+            debug!(" >> FAIL: no application buffer supplied!");
+            // Must supply buffer before performing receive operation
+            ReturnCode::EINVAL
+        }
+    }
+}
+
+impl<'a> nfc::Client<'a> for NfcDriver<'a> {
+    fn tag_selected(&self) {
+        self.driver_selected.set(true);
+        // 0xfffff results in 1048575 / 13.56e6 = 77ms
+        // The anti-collision is finished, we can now
+        // set the frame delay to the maximum value
+        self.driver.set_framedelaymax(0xfffff);
+    }
+
+    fn tag_deactivated(&self) {
+        self.reset();
+    }
+
+    fn field_detected(&self) {
+        self.current_field.set(nfc::NfcFieldState::On);
+    }
+
+    fn field_lost(
+        &self,
+        rx_buffer: Option<&'static mut [u8]>,
+        tx_buffer: Option<&'static mut [u8]>,
+    ) {
+        // Check any unanswered CBs and retake ownership of the buffers
+        if self.rx_in_progress.is_some() {
+            self.rx_buffer.replace(rx_buffer.unwrap());
+            self.rx_in_progress.take().map(|appid| {
+                let _ = self.application.enter(appid, |app, _| {
+                    app.rx_callback
+                        .map(|mut cb| cb.schedule((ReturnCode::ECANCEL).into(), 0, 0));
+                });
+            });
+        }
+        if self.tx_in_progress.is_some() {
+            self.tx_buffer.replace(tx_buffer.unwrap());
+            self.tx_in_progress.take().map(|appid| {
+                let _ = self.application.enter(appid, |app, _| {
+                    app.tx_callback
+                        .map(|mut cb| cb.schedule((ReturnCode::ECANCEL).into(), 0, 0));
+                });
+            });
+        }
+        self.reset();
+    }
+
+    fn frame_received(&self, buffer: &'static mut [u8], rx_len: usize, result: ReturnCode) {
+        self.rx_buffer.replace(buffer);
+        self.rx_in_progress.take().map(|appid| {
+            let _ = self.application.enter(appid, |app, _| {
+                app.rx_buffer = app.rx_buffer.take().map(|mut rb| {
+                    // Figure out length to copy.
+                    let max_len = cmp::min(rx_len, rb.len());
+                    // Copy over data to app buffer.
+                    self.rx_buffer.map(|buffer| {
+                        for idx in 0..max_len {
+                            rb.as_mut()[idx] = buffer[idx];
+                        }
+                    });
+                    app.rx_callback
+                        .map(|mut cb| cb.schedule(result.into(), max_len, 0));
+                    rb
+                });
+            });
+        });
+    }
+
+    fn frame_transmitted(&self, buffer: &'static mut [u8], result: ReturnCode) {
+        self.tx_buffer.replace(buffer);
+        self.tx_in_progress.take().map(|appid| {
+            let _ = self.application.enter(appid, |app, _| {
+                app.tx_callback
+                    .map(|mut cb| cb.schedule(result.into(), 0, 0));
+            });
+        });
+    }
+}
+
+impl Driver for NfcDriver<'_> {
+    /// Setup shared buffers.
+    ///
+    /// ### `allow_num`
+    ///
+    /// - `1`: Readable buffer for transmission buffer, if
+    ///        provided buffer length is more than MAX_LENGTH then
+    ///        return EINVAL
+    /// - `2`: Writeable buffer for reception buffer, if
+    ///        provided buffer length is not MAX_LENGTH then
+    ///        return EINVAL
+    fn allow(
+        &self,
+        appid: AppId,
+        allow_num: usize,
+        slice: Option<AppSlice<Shared, u8>>,
+    ) -> ReturnCode {
+        match allow_num {
+            1 => self
+                .application
+                .enter(appid, |app, _| {
+                    if let Some(buf) = &slice {
+                        if buf.len() > MAX_LENGTH {
+                            return ReturnCode::EINVAL;
+                        }
+                    }
+                    app.tx_buffer = slice;
+                    ReturnCode::SUCCESS
+                })
+                .unwrap_or_else(|err| err.into()),
+            2 => self
+                .application
+                .enter(appid, |app, _| {
+                    if let Some(buf) = &slice {
+                        if buf.len() != MAX_LENGTH {
+                            return ReturnCode::EINVAL;
+                        }
+                    }
+                    app.rx_buffer = slice;
+                    ReturnCode::SUCCESS
+                })
+                .unwrap_or_else(|err| err.into()),
+            _ => ReturnCode::ENOSUPPORT,
+        }
+    }
+
+    /// Setup callbacks.
+    ///
+    /// ### `subscribe_num`
+    ///
+    /// - `1`: Frame transmission completed callback
+    /// - `2`: Frame reception completed callback
+    fn subscribe(
+        &self,
+        subscribe_num: usize,
+        callback: Option<Callback>,
+        appid: AppId,
+    ) -> ReturnCode {
+        match subscribe_num {
+            1 => self
+                .application
+                .enter(appid, |app, _| {
+                    app.tx_callback = callback;
+                    ReturnCode::SUCCESS
+                })
+                .unwrap_or_else(|err| err.into()),
+            2 => self
+                .application
+                .enter(appid, |app, _| {
+                    app.rx_callback = callback;
+                    ReturnCode::SUCCESS
+                })
+                .unwrap_or_else(|err| err.into()),
+            _ => ReturnCode::ENOSUPPORT,
+        }
+    }
+
+    /// NFC control
+    ///
+    /// ### `command_num`
+    ///
+    /// - `0`: Driver check.
+    /// - `1`: Transmits a buffer passed via `allow`, up to the length
+    ///        passed in `arg1`.
+    /// - `2`: Receives into a buffer passed via `allow`, up to the length
+    ///        passed in `arg1`.
+    /// - `3`: Controls tag emulation, enables it if the value in `arg1`
+    ///        is positive, disables it in case of 0.
+    /// - `4`: Configures the tag based on the value of `arg1`.
+    fn command(&self, command_num: usize, arg1: usize, _: usize, appid: AppId) -> ReturnCode {
+        match command_num {
+            0 /* check if present */ => ReturnCode::SUCCESS,
+            1 => {
+                let len = arg1;
+                self.application.enter(appid, |app, _| {
+                    self.transmit_new(appid, app, len)
+                }).unwrap_or_else(|err| err.into())
+            },
+            2 => {
+                let len = arg1;
+                self.application.enter(appid, |app, _| {
+                    self.receive_new(appid, app, len)
+                }).unwrap_or_else(|err| err.into())
+            },
+            3 /* enable tag emulation */=> {
+                self.application.enter(appid, |_, _| {
+                    match arg1 as u8 {
+                        0 /* false */ => self.driver.deactivate(),
+                        _ /* true */ => self.driver.activate(),
+                    }
+                    ReturnCode::SUCCESS
+                }).unwrap_or_else(|err| err.into())
+            }
+            4 /* tag type configuration */ => {
+                self.application.enter(appid, |_, _| {
+                    self.tag_configured.set(true);
+                    let tag_type = arg1;
+                    self.driver.configure(tag_type as u8)
+                }).unwrap_or_else(|err| err.into())
+            }
+            _ => ReturnCode::ENOSUPPORT,
+        }
+    }
+}
diff --git a/chips/nrf52/src/interrupt_service.rs b/chips/nrf52/src/interrupt_service.rs
index 30767072a..06bf769e8 100644
--- a/chips/nrf52/src/interrupt_service.rs
+++ b/chips/nrf52/src/interrupt_service.rs
@@ -3,6 +3,7 @@ use crate::adc;
 use crate::ble_radio;
 use crate::i2c;
 use crate::ieee802154_radio;
+use crate::nfct;
 use crate::power;
 use crate::spi;
 use crate::uart;
@@ -123,6 +124,7 @@ impl InterruptService for Nrf52InterruptService<'_> {
             }
             peripheral_interrupts::SPIM2_SPIS2_SPI2 => spi::SPIM2.handle_interrupt(),
             peripheral_interrupts::ADC => adc::ADC.handle_interrupt(),
+            peripheral_interrupts::NFCT => nfct::NFCT.handle_interrupt(),
             _ => return false,
         }
         true
diff --git a/chips/nrf52/src/lib.rs b/chips/nrf52/src/lib.rs
index c9ae44148..1677939bf 100644
--- a/chips/nrf52/src/lib.rs
+++ b/chips/nrf52/src/lib.rs
@@ -14,6 +14,7 @@ pub mod ficr;
 pub mod i2c;
 pub mod ieee802154_radio;
 pub mod interrupt_service;
+pub mod nfct;
 pub mod nvmc;
 pub mod power;
 pub mod ppi;
diff --git a/chips/nrf52/src/nfct.rs b/chips/nrf52/src/nfct.rs
new file mode 100644
index 000000000..d7b7cbed1
--- /dev/null
+++ b/chips/nrf52/src/nfct.rs
@@ -0,0 +1,737 @@
+//! Near Field Communication Tag (NFCT)
+//!
+//! Author
+//! -------------------
+//!
+//! * Jean-Michel Picod <jmichel@google.com>
+//! * Mirna Al-Shetairy <mshetairy@google.com>
+
+use core::cell::Cell;
+use kernel::common::cells::{OptionalCell, TakeCell};
+use kernel::common::registers::{
+    register_bitfields, register_structs, InMemoryRegister, ReadOnly, ReadWrite, WriteOnly,
+};
+use kernel::common::StaticRef;
+use kernel::debug;
+use kernel::hil;
+use kernel::hil::nfc::NfcFieldState;
+use kernel::ReturnCode;
+
+const NFCT_BASE: StaticRef<NfctRegisters> =
+    unsafe { StaticRef::new(0x40005000 as *const NfctRegisters) };
+
+register_structs! {
+    NfctRegisters {
+        /// Activate NFCT peripheral for incoming and outgoing frames, change
+        /// state to activated.
+        (0x000 => task_activate: WriteOnly<u32, Task::Register>),
+        /// Disable NFCT peripheral
+        (0x004 => task_disable: WriteOnly<u32, Task::Register>),
+        /// Enable NFC sense field mode, change state to sense mode
+        (0x008 => task_sense: WriteOnly<u32, Task::Register>),
+        /// Start transmission of an outgoing frame, change state to transmit
+        (0x00C => task_starttx: WriteOnly<u32, Task::Register>),
+        (0x010 => _reserved1),
+        /// Initialized the EasyDMA for receive
+        (0x01C => task_enablerxdata: WriteOnly<u32, Task::Register>),
+        (0x020 => _reserved2),
+        /// Force state machine to IDLE state
+        (0x024 => task_goidle: WriteOnly<u32, Task::Register>),
+        /// Force state machine to SLEEP_A state
+        (0x028 => task_gosleep: WriteOnly<u32, Task::Register>),
+        (0x02C => _reserved3),
+        /// The NFCT peripheral is ready to receive and send frames
+        (0x100 => event_ready: ReadWrite<u32, Event::Register>),
+        /// Remote NFC field detected
+        (0x104 => event_fielddetected: ReadWrite<u32, Event::Register>),
+        /// Remote NFC field lost
+        (0x108 => event_fieldlost: ReadWrite<u32, Event::Register>),
+        /// Marks the start of the first symbol of a transmitted frame
+        (0x10C => event_txframestart: ReadWrite<u32, Event::Register>),
+        /// Marks the end of the last transmitted on-air symbol of a frame
+        (0x110 => event_txframeend: ReadWrite<u32, Event::Register>),
+        /// Marks the end of the first symbol of a received frame
+        (0x114 => event_rxframestart: ReadWrite<u32, Event::Register>),
+        /// Received data has been checked (CRC, parity) and transferred to
+        /// RAM, and EasyDMA has ended accessing the RX buffer
+        (0x118 => event_rxframeend: ReadWrite<u32, Event::Register>),
+        /// NFC error reported. The ERRORSTATUS register contains details on
+        /// the source of error
+        (0x11C => event_error: ReadWrite<u32, Event::Register>),
+        (0x120 => _reserved4),
+        /// NFC RX frame error reported. The FRAMESTATUS.RX register contains
+        /// details on the source of error
+        (0x128 => event_rxerror: ReadWrite<u32, Event::Register>),
+        /// RX buffer (as defined by PACKETPTR and MAXLEN) in data RAM full
+        (0x12C => event_endrx: ReadWrite<u32, Event::Register>),
+        /// Transmission of data in RAM has ended, and EasyDMA has ended
+        /// accessing the TX buffer
+        (0x130 => event_endtx: ReadWrite<u32, Event::Register>),
+        (0x134 => _reserved5),
+        /// Auto collision resolution process has started
+        (0x138 => event_autocolresstarted: ReadWrite<u32, Event::Register>),
+        (0x13C => _reserved6),
+        /// NFC auto collision resolution error reported
+        (0x148 => event_collision: ReadWrite<u32, Event::Register>),
+        /// NFC auto collision resolution successfully completed
+        (0x14C => event_selected: ReadWrite<u32, Event::Register>),
+        /// EasyDMA is ready to receive or send frames
+        (0x150 => event_started: ReadWrite<u32, Event::Register>),
+        (0x154 => _reserved7),
+        /// Shortcuts between local events and tasks
+        (0x200 => shorts: ReadWrite<u32, Shorts::Register>),
+        (0x204 => _reserved9),
+        /// Enable or disable interrupt
+        (0x300 => inten: ReadWrite<u32, Interrupt::Register>),
+        /// Enable interrupt
+        (0x304 => intenset: ReadWrite<u32, Interrupt::Register>),
+        /// Disable interrupt
+        (0x308 => intenclr: ReadWrite<u32, Interrupt::Register>),
+        (0x30C => _reserved10),
+        /// NFC Error Status register
+        (0x404 => errorstatus: ReadWrite<u32, ErrorStatus::Register>),
+        (0x408 => _reserved11),
+        /// Result of last incoming frame
+        (0x40C => framestatus_rx: ReadWrite<u32, FrameStatus::Register>),
+        /// NfcTag State register
+        (0x410 => nfctagstate: ReadOnly<u32, NfcTagState::Register>),
+        (0x414 => _reserved12),
+        /// Sleep state during automatic collision resolution
+        (0x420 => sleepstate: ReadOnly<u32, SleepState::Register>),
+        (0x424 => _reserved13),
+        /// Indicates the presence or not of a valid field
+        (0x43C => fieldpresent: ReadOnly<u32, FieldPresent::Register>),
+        (0x440 => _reserved14),
+        /// Minimum frame delay
+        (0x504 => framedelay_min: ReadWrite<u32, FrameDelayMin::Register>),
+        /// Maximum frame delay
+        (0x508 => framedelay_max: ReadWrite<u32, FrameDelayMax::Register>),
+        /// Configuration register for the Frame Delay Timer
+        (0x50C => framedelay_mode: ReadWrite<u32, FrameDelayMode::Register>),
+        /// Packet pointer for TXD and RXD data storage in Data RAM
+        (0x510 => packetptr: ReadWrite<u32, Pointer::Register>),
+        /// Size of the RAM buffer allocated to TXD and RXD data storage each
+        (0x514 => maxlen: ReadWrite<u32, MaxLen::Register>),
+        /// Configuration of outgoing frames
+        (0x518 => txd_frameconfig: ReadWrite<u32, TxdFrameConfig::Register>),
+        /// Size of outgoing frame
+        (0x51C => txd_amount: ReadWrite<u32, Amount::Register>),
+        /// Configuration of incoming frames
+        (0x520 => rxd_frameconfig: ReadWrite<u32, RxdFrameConfig::Register>),
+        /// Size of incoming frame
+        (0x524 => rxd_amount: ReadOnly<u32, Amount::Register>),
+        (0x528 => _reserved15),
+        /// Last NFCID1 part (4, 7 or 10 bytes ID)
+        (0x590 => nfcid1_last: ReadWrite<u32, NfcIdPart3::Register>),
+        /// Second last NFCID1 part (7 or 10 bytes ID)
+        (0x594 => nfcid1_2nd_last: ReadWrite<u32, NfcIdPart2::Register>),
+        /// Third last NFCID1 part (10 bytes ID)
+        (0x598 => nfcid1_3rd_last: ReadWrite<u32, NfcIdPart1::Register>),
+        /// Controls the auto collision resolution function.
+        /// This setting must be done before the NFCT peripheral is enabled
+        (0x59C => autocolresconfig: ReadWrite<u32, AutoColConfig::Register>),
+        /// NFC-A SENS_RES auto-response settings
+        (0x5A0 => sensres: ReadWrite<u32, SensRes::Register>),
+        /// NFC-A SEL_RES auto-response settings
+        (0x5A4 => selres: ReadWrite<u32, SelRes::Register>),
+        (0x5A8 => _reserved16),
+        /// Errata 98: NFCT: Not able to communicate with the peer
+        /// Undocumented register
+        (0x68C => errata98: WriteOnly<u32>),
+        (0x690 => @END),
+    }
+}
+
+register_bitfields![u32,
+    /// Start task
+    Task [
+        ENABLE OFFSET(0) NUMBITS(1) [
+            Trigger = 1
+        ]
+    ],
+
+    /// Read event
+    Event [
+        GENERATED OFFSET(0) NUMBITS(1) [
+            NotGenerated = 0,
+            Generated = 1
+        ]
+    ],
+
+    /// Shortcuts
+    Shorts [
+        // Shortcut between event FIELDDETECTED and task ACTIVATE
+        FIELDDETECTED_ACTIVATE OFFSET(0) NUMBITS(1),
+        // Shortcut between event FIELDLOST and task SENSE
+        FIELDLOST_SENSE OFFSET(1) NUMBITS(1),
+        // Shortcut between event TXFRAMEEND and task ENABLERXDATA
+        TXFRAMEEND_ENABLERXDATA OFFSET(5) NUMBITS(1)
+    ],
+
+    // NFC Interrupts
+    Interrupt [
+        READY OFFSET(0) NUMBITS(1),
+        FIELDDETECTED OFFSET(1) NUMBITS(1),
+        FIELDLOST OFFSET(2) NUMBITS(1),
+        TXFRAMESTART OFFSET(3) NUMBITS(1),
+        TXFRAMEEND OFFSET(4) NUMBITS(1),
+        RXFRAMESTART OFFSET(5) NUMBITS(1),
+        RXFRAMEEND OFFSET(6) NUMBITS(1),
+        ERROR OFFSET(7) NUMBITS(1),
+        RXERROR OFFSET(10) NUMBITS(1),
+        ENDRX OFFSET(11) NUMBITS(1),
+        ENDTX OFFSET(12) NUMBITS(1),
+        AUTOCOLRESSTARTED OFFSET(14) NUMBITS(1),
+        COLLISION OFFSET(18) NUMBITS(1),
+        SELECTED OFFSET(19) NUMBITS(1),
+        STARTED OFFSET(20) NUMBITS(1)
+    ],
+
+    ErrorStatus [
+        FRAMEDELAYTIMEOUT OFFSET(0) NUMBITS(1)
+    ],
+
+    FrameStatus [
+        CRCERROR OFFSET(0) NUMBITS(1) [
+            CRCCorrect = 0,
+            CRCError = 1
+        ],
+        PARITYSTATUS OFFSET(2) NUMBITS(1) [
+            ParityOk = 0,
+            ParityError = 1
+        ],
+        OVERRUN OFFSET(3) NUMBITS(1) [
+            NoOverrun = 0,
+            Overrun = 1
+        ]
+    ],
+
+    NfcTagState [
+        NFCTAGSTATE OFFSET(0) NUMBITS(3) [
+            Disabled = 0,
+            RampUp = 2,
+            Idle = 3,
+            Receive = 4,
+            FrameDelay = 5,
+            Transmit = 6
+        ]
+    ],
+
+    SleepState [
+        SLEEPSTATE OFFSET(0) NUMBITS(1) [
+            Idle = 0,
+            SleepA = 1
+        ]
+    ],
+
+    FieldPresent [
+        FIELDPRESENT OFFSET(0) NUMBITS(1) [
+            NoField = 0,
+            FieldPresent = 1
+        ],
+        LOCKDETECT OFFSET(1) NUMBITS(1) [
+            NotLocked = 0,
+            Locked = 1
+        ]
+    ],
+
+    FrameDelayMin [
+        FRAMEDELAYMIN OFFSET(0) NUMBITS(16)
+    ],
+
+    FrameDelayMax [
+        FRAMEDELAYMAX OFFSET(0) NUMBITS(20)
+    ],
+
+    FrameDelayMode [
+        FRAMEDELAYMODE OFFSET(0) NUMBITS(2) [
+            FreeRun = 0,
+            Window = 1,
+            ExactVal = 2,
+            WindowGrid = 3
+        ]
+    ],
+
+    Pointer [
+        POINTER OFFSET(0) NUMBITS(32)
+    ],
+
+    MaxLen [
+        LEN OFFSET(0) NUMBITS(9)
+    ],
+
+    TxdFrameConfig [
+        PARITY OFFSET(0) NUMBITS(1) [
+            NoParity = 0,
+            Parity = 1
+        ],
+        DISCARDMODE OFFSET(1) NUMBITS(1) [
+            DiscardEnd = 0,
+            DiscardStart = 1
+        ],
+        SOF OFFSET(2) NUMBITS(1) [
+            NoSoF = 0,
+            SoF = 1
+        ],
+        CRCMODETX OFFSET(4) NUMBITS(1) [
+            NoCRCTX = 0,
+            CRC16TX = 1
+        ]
+    ],
+
+    Amount [
+        DATABITS OFFSET(0) NUMBITS(3),
+        DATABYTES OFFSET(3) NUMBITS(9)
+    ],
+
+    RxdFrameConfig [
+        PARITY OFFSET(0) NUMBITS(1) [
+            NoParity = 0,
+            Parity = 1
+        ],
+        SOF OFFSET(2) NUMBITS(1) [
+            NoSoF = 0,
+            SoF = 1
+        ],
+        CRCMODERX OFFSET(4) NUMBITS(1) [
+            NoCRCRX = 0,
+            CRC16RX = 1
+        ]
+    ],
+
+    NfcIdPart3 [
+        Z OFFSET(0) NUMBITS(8),
+        Y OFFSET(8) NUMBITS(8),
+        X OFFSET(16) NUMBITS(8),
+        W OFFSET(24) NUMBITS(8)
+    ],
+
+    NfcIdPart2 [
+        V OFFSET(0) NUMBITS(8),
+        U OFFSET(8) NUMBITS(8),
+        T OFFSET(16) NUMBITS(8)
+    ],
+
+    NfcIdPart1 [
+        S OFFSET(0) NUMBITS(8),
+        R OFFSET(8) NUMBITS(8),
+        Q OFFSET(16) NUMBITS(8)
+    ],
+
+    AutoColConfig [
+        MODE OFFSET(0) NUMBITS(1) [
+            Enabled = 0,
+            Disabled = 1
+        ]
+    ],
+
+    SensRes [
+        BITFRAMESDD OFFSET(0) NUMBITS(5) [
+            SDD00000 = 0,
+            SDD00001 = 1,
+            SDD00010 = 2,
+            SDD00100 = 4,
+            SDD01000 = 8,
+            SDD10000 = 16
+        ],
+        NFCIDSIZE OFFSET(6) NUMBITS(2) [
+            NFCID1Single = 0,
+            NFCID1Double = 1,
+            NFCID1Triple = 2
+        ],
+        PLATFCONFIG OFFSET(8) NUMBITS(4) []
+    ],
+
+    SelRes [
+        CASCADE OFFSET(2) NUMBITS(1) [],
+        PROTOCOL OFFSET(5) NUMBITS(2) [
+            Type2 = 0,
+            Type4A = 1,
+            NfcDep = 2,
+            NfcDepAndType4A = 3
+        ]
+    ]
+];
+
+#[derive(Copy, Clone, Debug, PartialEq)]
+pub enum TagType {
+    Type1,
+    Type2,
+    Type3,
+    Type4,
+    Type5,
+    Unknown,
+}
+
+#[derive(Copy, Clone, Debug, PartialEq)]
+pub enum NfcState {
+    Disabled,
+    Initialized,
+    Activated,
+    Transmitting,
+    Transmitted,
+    Receiving,
+    Received,
+}
+
+pub static mut NFCT: NfcTag = NfcTag::new();
+
+pub struct NfcTag<'a> {
+    registers: StaticRef<NfctRegisters>,
+    client: OptionalCell<&'a dyn hil::nfc::Client<'a>>,
+    // To keep additional code-related states
+    state: Cell<NfcState>,
+    // For storing the buffers' references.
+    tx_buffer: TakeCell<'static, [u8]>,
+    rx_buffer: TakeCell<'static, [u8]>,
+    tag_type: Cell<TagType>,
+}
+
+impl<'a> NfcTag<'a> {
+    pub const fn new() -> Self {
+        Self {
+            registers: NFCT_BASE,
+            client: OptionalCell::empty(),
+            state: Cell::new(NfcState::Disabled),
+            tx_buffer: TakeCell::empty(),
+            rx_buffer: TakeCell::empty(),
+            tag_type: Cell::new(TagType::Unknown),
+        }
+    }
+
+    /// Helper function to mask false bits
+    fn mask_rx_bits(&self, buf: &mut [u8]) {
+        let amount = self.registers.rxd_amount.read(Amount::DATABYTES) as usize;
+        let bits = self.registers.rxd_amount.read(Amount::DATABITS);
+        if bits == 0 {
+            return;
+        }
+        if amount < buf.len() {
+            // bit_and with 2^bits - 1
+            buf[amount] &= (1 << bits) - 1;
+        }
+    }
+
+    fn get_state(&self) -> NfcState {
+        self.state.get()
+    }
+
+    fn get_rx_amount(&self) -> u32 {
+        let rx_amount = self.registers.rxd_amount.read(Amount::DATABYTES)
+            + match self.registers.rxd_amount.read(Amount::DATABITS) {
+                0 => 0,
+                _ => 1,
+            };
+        // If CRC bytes are counted
+        if rx_amount > 2 {
+            return rx_amount - 2;
+        }
+        rx_amount
+    }
+
+    fn field_check(&self) -> bool {
+        if !self
+            .registers
+            .fieldpresent
+            .is_set(FieldPresent::FIELDPRESENT)
+            && !self.registers.fieldpresent.is_set(FieldPresent::LOCKDETECT)
+        {
+            // No active field
+            return false;
+        }
+        true
+    }
+
+    fn handle_selected(&self) {
+        self.state.set(NfcState::Activated);
+        self.client.map(|client| client.tag_selected());
+    }
+
+    fn handle_rxend(&self) {
+        self.state.set(NfcState::Received);
+        // Return the buffer to the capsule
+        self.client.map(|client| {
+            self.rx_buffer.take().map(|rx_buffer| {
+                let returncode = if self.registers.framestatus_rx.is_set(FrameStatus::OVERRUN) {
+                    ReturnCode::ENOMEM
+                } else if self.registers.framestatus_rx.is_set(FrameStatus::CRCERROR)
+                    || self
+                        .registers
+                        .framestatus_rx
+                        .is_set(FrameStatus::PARITYSTATUS)
+                {
+                    ReturnCode::FAIL
+                } else {
+                    ReturnCode::SUCCESS
+                };
+                let rx_amount = self.get_rx_amount() as usize;
+                self.mask_rx_bits(rx_buffer);
+                client.frame_received(rx_buffer, rx_amount, returncode);
+            });
+        });
+        self.clear_errors();
+    }
+
+    fn handle_txend(&self) {
+        self.state.set(NfcState::Transmitted);
+        // Return the buffer to the capsule
+        self.client.map(|client| {
+            self.tx_buffer.take().map(|tx_buffer| {
+                let returncode = if self
+                    .registers
+                    .errorstatus
+                    .is_set(ErrorStatus::FRAMEDELAYTIMEOUT)
+                {
+                    ReturnCode::FAIL
+                } else {
+                    ReturnCode::SUCCESS
+                };
+                client.frame_transmitted(tx_buffer, returncode);
+            });
+        });
+        self.clear_errors();
+    }
+
+    fn handle_field(&self, mut field_state: NfcFieldState) {
+        if field_state == NfcFieldState::Unknown {
+            field_state = if self.field_check() {
+                NfcFieldState::On
+            } else {
+                NfcFieldState::Off
+            };
+        }
+
+        match field_state {
+            NfcFieldState::On => self.client.map(|client| client.field_detected()).unwrap(),
+            NfcFieldState::Off => self
+                .client
+                .map(|client| client.field_lost(self.rx_buffer.take(), self.tx_buffer.take()))
+                .unwrap(),
+            _ => (),
+        }
+    }
+
+    /// Helper function that clears TX/RX errors related registers.
+    fn clear_errors(&self) {
+        self.registers
+            .errorstatus
+            .set(self.registers.errorstatus.get());
+        self.registers
+            .framestatus_rx
+            .set(self.registers.framestatus_rx.get());
+    }
+
+    pub fn handle_interrupt(&self) {
+        let mut current_field = NfcFieldState::None;
+        let saved_inter = self.registers.intenset.extract();
+        self.disable_all_interrupts();
+
+        let active_events = self.active_events();
+        let events_to_process = saved_inter.bitand(active_events.get());
+        if events_to_process.is_set(Interrupt::FIELDDETECTED) {
+            current_field = NfcFieldState::On;
+        }
+        if events_to_process.is_set(Interrupt::FIELDLOST) {
+            current_field = match current_field {
+                NfcFieldState::None => NfcFieldState::Off,
+                _ => NfcFieldState::Unknown,
+            }
+        }
+        if current_field != NfcFieldState::None {
+            self.handle_field(current_field);
+        }
+
+        if events_to_process.is_set(Interrupt::RXFRAMEEND) {
+            self.handle_rxend();
+        }
+        if events_to_process.is_set(Interrupt::TXFRAMEEND) {
+            self.handle_txend();
+        }
+        if events_to_process.is_set(Interrupt::SELECTED) {
+            self.handle_selected();
+        }
+        // Ensure there are no spurious errors.
+        self.clear_errors();
+        self.enable_interrupts();
+    }
+
+    fn active_events(&self) -> InMemoryRegister<u32, Interrupt::Register> {
+        let result = InMemoryRegister::new(0);
+        if NfcTag::take_event(&self.registers.event_ready) {
+            result.modify(Interrupt::READY::SET);
+        }
+        if NfcTag::take_event(&self.registers.event_fielddetected) {
+            result.modify(Interrupt::FIELDDETECTED::SET);
+        }
+        if NfcTag::take_event(&self.registers.event_fieldlost) {
+            result.modify(Interrupt::FIELDLOST::SET);
+        }
+        if NfcTag::take_event(&self.registers.event_txframestart) {
+            result.modify(Interrupt::TXFRAMESTART::SET);
+        }
+        if NfcTag::take_event(&self.registers.event_txframeend) {
+            result.modify(Interrupt::TXFRAMEEND::SET);
+        }
+        if NfcTag::take_event(&self.registers.event_rxframestart) {
+            result.modify(Interrupt::RXFRAMESTART::SET);
+        }
+        if NfcTag::take_event(&self.registers.event_rxframeend) {
+            result.modify(Interrupt::RXFRAMEEND::SET);
+        }
+        if NfcTag::take_event(&self.registers.event_error) {
+            result.modify(Interrupt::ERROR::SET);
+        }
+        if NfcTag::take_event(&self.registers.event_rxerror) {
+            result.modify(Interrupt::RXERROR::SET);
+        }
+        if NfcTag::take_event(&self.registers.event_endrx) {
+            result.modify(Interrupt::ENDRX::SET);
+        }
+        if NfcTag::take_event(&self.registers.event_endtx) {
+            result.modify(Interrupt::ENDTX::SET);
+        }
+        if NfcTag::take_event(&self.registers.event_autocolresstarted) {
+            result.modify(Interrupt::AUTOCOLRESSTARTED::SET);
+        }
+        if NfcTag::take_event(&self.registers.event_collision) {
+            result.modify(Interrupt::COLLISION::SET);
+        }
+        if NfcTag::take_event(&self.registers.event_selected) {
+            result.modify(Interrupt::SELECTED::SET);
+        }
+        if NfcTag::take_event(&self.registers.event_started) {
+            result.modify(Interrupt::STARTED::SET);
+        }
+        result
+    }
+
+    // Reads the status of an Event register and clears the register.
+    // Returns the READY status.
+    fn take_event(event: &ReadWrite<u32, Event::Register>) -> bool {
+        let result = event.is_set(Event::GENERATED);
+        if result {
+            event.write(Event::GENERATED::CLEAR);
+        }
+        result
+    }
+
+    fn disable_all_interrupts(&self) {
+        self.registers.intenclr.set(0xffffffff);
+    }
+
+    /// Enable the main event interrupts
+    fn enable_interrupts(&self) {
+        self.registers.intenset.write(
+            Interrupt::SELECTED::SET + Interrupt::FIELDLOST::SET + Interrupt::FIELDDETECTED::SET,
+        );
+    }
+
+    fn configure(&self) {
+        self.clear_errors();
+        self.registers
+            .sensres
+            .modify(SensRes::BITFRAMESDD::SDD00100);
+        match self.tag_type.get() {
+            TagType::Type4 => self.registers.selres.modify(SelRes::PROTOCOL::Type4A),
+            _ => (),
+        }
+    }
+
+    fn enable(&self) {
+        self.registers.errata98.set(0x38148);
+        self.registers
+            .framedelay_mode
+            .write(FrameDelayMode::FRAMEDELAYMODE::WindowGrid);
+        self.registers.framedelay_max.set(0x1000);
+        // TODO: Remove TASKS_ACTIVATE and Enable TASKS_SENSE instead.
+        self.registers.task_activate.write(Task::ENABLE::Trigger);
+        self.enable_interrupts();
+        self.state.set(NfcState::Initialized);
+    }
+
+    fn disable(&self) {
+        self.state.set(NfcState::Disabled);
+        self.disable_all_interrupts();
+        self.registers.task_disable.write(Task::ENABLE::Trigger);
+    }
+
+    pub fn set_dma_registers(&self, buffer: &[u8]) {
+        let len: u32 = buffer.len() as u32;
+        self.registers.packetptr.set(buffer.as_ptr() as u32);
+        self.registers.maxlen.write(MaxLen::LEN.val(len));
+        if self.get_state() == NfcState::Transmitting {
+            self.registers
+                .txd_amount
+                .write(Amount::DATABYTES.val(len) + Amount::DATABITS::CLEAR);
+        }
+    }
+}
+
+impl<'a> hil::nfc::NfcTag<'a> for NfcTag<'a> {
+    fn set_client(&self, client: &'a dyn hil::nfc::Client<'a>) {
+        self.client.set(client);
+    }
+
+    fn enable(&self) {
+        self.enable();
+    }
+
+    fn activate(&self) {
+        self.enable();
+        self.registers.task_activate.write(Task::ENABLE::Trigger);
+    }
+
+    fn deactivate(&self) {
+        self.client.map(|client| client.tag_deactivated());
+        self.disable();
+        // TODO: Enable task sense when it's correctly configured.
+    }
+
+    fn transmit_buffer(
+        &self,
+        buf: &'static mut [u8],
+        amount: usize,
+    ) -> Result<usize, (ReturnCode, &'static mut [u8])> {
+        self.state.set(NfcState::Transmitting);
+        self.set_dma_registers(&buf[..amount]);
+        self.tx_buffer.replace(buf);
+        self.registers.intenset.modify(Interrupt::TXFRAMEEND::SET);
+        self.clear_errors();
+        self.registers.task_starttx.write(Task::ENABLE::Trigger);
+        Ok(amount)
+    }
+
+    fn receive_buffer(
+        &self,
+        buf: &'static mut [u8],
+    ) -> Result<(), (ReturnCode, &'static mut [u8])> {
+        self.state.set(NfcState::Receiving);
+        self.set_dma_registers(buf);
+        self.rx_buffer.replace(buf);
+        self.registers.intenset.modify(Interrupt::RXFRAMEEND::SET);
+        self.registers
+            .task_enablerxdata
+            .write(Task::ENABLE::Trigger);
+        Ok(())
+    }
+
+    fn configure(&self, tag_type: u8) -> ReturnCode {
+        match tag_type {
+            4 => self.tag_type.set(TagType::Type4),
+            _ => {
+                debug!("No implementation for this tag type.");
+                return ReturnCode::ENOSUPPORT;
+            }
+        }
+        self.configure();
+        ReturnCode::SUCCESS
+    }
+
+    fn set_framedelaymax(&self, max_delay: u32) {
+        self.registers.framedelay_max.set(max_delay);
+    }
+
+    fn unmask_select(&self) {
+        self.registers.intenset.write(Interrupt::SELECTED::SET);
+    }
+}
diff --git a/chips/nrf52840/src/lib.rs b/chips/nrf52840/src/lib.rs
index ce73e1f82..628a33567 100644
--- a/chips/nrf52840/src/lib.rs
+++ b/chips/nrf52840/src/lib.rs
@@ -1,8 +1,8 @@
 #![no_std]
 
 pub use nrf52::{
-    acomp, adc, aes, ble_radio, clock, constants, crt1, ficr, i2c, ieee802154_radio, init, nvmc,
-    pinmux, power, ppi, pwm, rtc, spi, temperature, timer, trng, uart, uicr, usbd,
+    acomp, adc, aes, ble_radio, clock, constants, crt1, ficr, i2c, ieee802154_radio, init, nfct,
+    nvmc, pinmux, power, ppi, pwm, rtc, spi, temperature, timer, trng, uart, uicr, usbd,
 };
 pub mod chip;
 pub mod gpio;
diff --git a/kernel/src/hil/mod.rs b/kernel/src/hil/mod.rs
index 83e7702ab..7fcfe4d4e 100644
--- a/kernel/src/hil/mod.rs
+++ b/kernel/src/hil/mod.rs
@@ -15,6 +15,7 @@ pub mod gpio_async;
 pub mod i2c;
 pub mod led;
 pub mod log;
+pub mod nfc;
 pub mod nonvolatile_storage;
 pub mod pwm;
 pub mod radio;
diff --git a/kernel/src/hil/nfc.rs b/kernel/src/hil/nfc.rs
new file mode 100644
index 000000000..f25f7c1a7
--- /dev/null
+++ b/kernel/src/hil/nfc.rs
@@ -0,0 +1,105 @@
+use crate::returncode::ReturnCode;
+
+#[derive(Copy, Clone, Debug, PartialEq)]
+/// An enum to keep track of the NFC field status
+pub enum NfcFieldState {
+    /// Initial value that indicates no NFCT field events.
+    None,
+    /// The NFCT FIELDLOST event has been set.
+    On,
+    /// The NFCT FIELDDETECTED event has been set.
+    Off,
+    /// Both NFCT field events have been set - ambiguous state.
+    Unknown,
+}
+
+/// Controls an NFC tag main functionalities
+pub trait NfcTag<'a> {
+    /// Set the client instance that will handle callbacks
+    fn set_client(&self, client: &'a dyn Client<'a>);
+
+    /// Enable NFC sense field mode, and subscribe to the relevant interrupts.
+    /// Also set up the default configurations of how frame delay should be
+    /// dealt with (e.g. the maximum delay before a timeout).
+    /// This function should never fail.
+    fn enable(&self);
+
+    /// Enable tag emulation by triggering the necessary task.
+    /// This function should never fail.
+    fn activate(&self);
+    /// Notify the client by calling `field_lost()`. Then disable tag emulation
+    /// by triggering the necessary task. And go back to state of sense field.
+    /// This function should never fail.
+    fn deactivate(&self);
+
+    /// Pass the buffer to be transmitted and the amount of data and take
+    /// ownership of it. Subscribe to the relevant interrupt and trigger
+    /// the task for transmission.
+    ///
+    /// On success returns the length of data to be sent.
+    /// On failure returns an error code and the buffer passed in.
+    fn transmit_buffer(
+        &self,
+        tx_buffer: &'static mut [u8],
+        tx_amount: usize,
+    ) -> Result<usize, (ReturnCode, &'static mut [u8])>;
+
+    /// Pass a buffer for receiving data and take ownership of it.
+    ///
+    /// On success returns nothing.
+    /// On failure returns an error code and the buffer passed in.
+    fn receive_buffer(
+        &self,
+        rx_buffer: &'static mut [u8],
+    ) -> Result<(), (ReturnCode, &'static mut [u8])>;
+
+    /// Configuration of the Tag according to its Type.
+    ///
+    /// Return `SUCCESS` if the tag type is supported and
+    /// `ENOSUPPORT` otherwise.
+    fn configure(&self, tag_type: u8) -> ReturnCode;
+
+    /// Set the maximum frame delay in number of 13.56 MHz clocks.
+    fn set_framedelaymax(&self, max_delay: u32);
+
+    /// Enable the interrupt for event SELECTED
+    fn unmask_select(&self);
+}
+
+/// Implement this trait and use `set_client()` in order to receive callbacks.
+pub trait Client<'a> {
+    /// Called when a selection event takes place.
+    /// This will call `set_framedelaymax()` to update
+    /// the default value in use.
+    fn tag_selected(&'a self);
+
+    // Reset the state automaton of the capsule.
+    fn tag_deactivated(&'a self);
+
+    /// Called when a field is detected.
+    /// This will notify the app of the presence of a field to activate the tag.
+    fn field_detected(&'a self);
+
+    /// Called when a field is lost.
+    /// This will notify the app of the absence of a field.
+    /// Returns any buffers passed either in `receive_buffer()` or `transmit_buffer()`
+    /// back to the capsule. Also trigger any ready callback functions.
+    fn field_lost(
+        &'a self,
+        rx_buffer: Option<&'static mut [u8]>,
+        tx_buffer: Option<&'static mut [u8]>,
+    );
+
+    /// Called when a frame is received.
+    /// This will return the buffer passed into `receive_buffer()`.
+    /// If the buffer length is smaller then the data length the buffer will only contain part
+    /// of the frame the `result` will contain an `ENOMEM` error. If the received frame contained
+    /// errors the `result` will contain a `FAIL` error.
+    fn frame_received(&'a self, buffer: &'static mut [u8], rx_len: usize, result: ReturnCode);
+
+    /// Called when a frame has finished transmitting.
+    /// This will return the buffer passed into `transmit_buffer()`.
+    /// If not all of the data could be sent because of a timeout the `result` will contain
+    /// a `FAIL` error.
+    fn frame_transmitted(&'a self, buffer: &'static mut [u8], result: ReturnCode);
+}
