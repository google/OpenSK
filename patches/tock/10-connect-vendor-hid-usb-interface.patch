diff --git a/capsules/src/usb/usb_ctap.rs b/capsules/src/usb/usb_ctap.rs
index da3d16d85..bd5337d30 100644
--- a/capsules/src/usb/usb_ctap.rs
+++ b/capsules/src/usb/usb_ctap.rs
@@ -91,7 +91,7 @@ pub trait CtapUsbClient {
     fn can_receive_packet(&self) -> bool;
 
     // Signal to the client that a packet has been received.
-    fn packet_received(&self, packet: &[u8; 64]);
+    fn packet_received(&self, packet: &[u8; 64], endpoint: usize);
 
     // Signal to the client that a packet has been transmitted.
     fn packet_transmitted(&self);
@@ -123,7 +123,7 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> CtapUsbClient for CtapUsbSyscallDri
         result
     }
 
-    fn packet_received(&self, packet: &[u8; 64]) {
+    fn packet_received(&self, packet: &[u8; 64], endpoint: usize) {
         for app in self.apps.iter() {
             app.enter(|app, _| {
                 if app.connected && app.waiting && app.side.map_or(false, |side| side.can_receive())
@@ -134,7 +134,7 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> CtapUsbClient for CtapUsbSyscallDri
                         app.waiting = false;
                         // Signal to the app that a packet is ready.
                         app.callback
-                            .map(|mut cb| cb.schedule(CTAP_CALLBACK_RECEIVED, 0, 0));
+                            .map(|mut cb| cb.schedule(CTAP_CALLBACK_RECEIVED, endpoint , 0));
                     }
                 }
             });
@@ -220,7 +220,7 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> Driver for CtapUsbSyscallDriver<'a,
             .unwrap_or_else(|err| err.into())
     }
 
-    fn command(&self, cmd_num: usize, _arg1: usize, _arg2: usize, appid: AppId) -> ReturnCode {
+    fn command(&self, cmd_num: usize, endpoint: usize, _arg2: usize, appid: AppId) -> ReturnCode {
         match cmd_num {
             CTAP_CMD_CHECK => ReturnCode::SUCCESS,
             CTAP_CMD_CONNECT => {
@@ -258,7 +258,7 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> Driver for CtapUsbSyscallDriver<'a,
                                 ReturnCode::EALREADY
                             } else if self
                                 .usb_client
-                                .transmit_packet(app.buffer.as_ref().unwrap().as_ref())
+                                .transmit_packet(app.buffer.as_ref().unwrap().as_ref(), endpoint)
                             {
                                 app.waiting = true;
                                 ReturnCode::SUCCESS
@@ -282,7 +282,7 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> Driver for CtapUsbSyscallDriver<'a,
                                 ReturnCode::EALREADY
                             } else {
                                 app.waiting = true;
-                                self.usb_client.receive_packet();
+                                self.usb_client.receive_packet(endpoint);
                                 ReturnCode::SUCCESS
                             }
                         } else {
@@ -303,7 +303,7 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> Driver for CtapUsbSyscallDriver<'a,
                             } else {
                                 // Indicates to the driver that we can receive any pending packet.
                                 app.waiting = true;
-                                self.usb_client.receive_packet();
+                                self.usb_client.receive_packet(endpoint);
 
                                 if !app.waiting {
                                     // The call to receive_packet() collected a pending packet.
@@ -312,7 +312,7 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> Driver for CtapUsbSyscallDriver<'a,
                                     // Indicates to the driver that we have a packet to send.
                                     if self
                                         .usb_client
-                                        .transmit_packet(app.buffer.as_ref().unwrap().as_ref())
+                                        .transmit_packet(app.buffer.as_ref().unwrap().as_ref(), endpoint)
                                     {
                                         ReturnCode::SUCCESS
                                     } else {
diff --git a/capsules/src/usb/usbc_ctap_hid.rs b/capsules/src/usb/usbc_ctap_hid.rs
index 41d69752c..60765704c 100644
--- a/capsules/src/usb/usbc_ctap_hid.rs
+++ b/capsules/src/usb/usbc_ctap_hid.rs
@@ -104,12 +104,17 @@ pub struct ClientCtapHID<'a, 'b, C: 'a> {
     in_buffer: Buffer64,
     out_buffer: Buffer64,
 
+    // 64-byte buffers for the endpoint
+    vendor_in_buffer: Buffer64,
+    vendor_out_buffer: Buffer64,
+
     // Interaction with the client
     client: OptionalCell<&'b dyn CtapUsbClient>,
     tx_packet: OptionalCell<[u8; 64]>,
     pending_in: Cell<bool>,
     pending_out: Cell<bool>,
-    delayed_out: Cell<bool>,
+    // The endpoint of the delayed packet, 0 indicates no delayed packet.
+    delayed_out: Cell<usize>,
 }
 
 impl<'a, 'b, C: hil::usb::UsbController<'a>> ClientCtapHID<'a, 'b, C> {
@@ -230,11 +235,14 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> ClientCtapHID<'a, 'b, C> {
             ),
             in_buffer: Buffer64::default(),
             out_buffer: Buffer64::default(),
+            vendor_in_buffer: Buffer64::default(),
+            vendor_out_buffer: Buffer64::default(),
             client: OptionalCell::empty(),
             tx_packet: OptionalCell::empty(),
             pending_in: Cell::new(false),
             pending_out: Cell::new(false),
-            delayed_out: Cell::new(false),
+            delayed_out: Cell::new(0), // 0 indicates no packet
+
         }
     }
 
@@ -242,7 +250,7 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> ClientCtapHID<'a, 'b, C> {
         self.client.set(client);
     }
 
-    pub fn transmit_packet(&'a self, packet: &[u8]) -> bool {
+    pub fn transmit_packet(&'a self, packet: &[u8], endpoint: usize) -> bool {
         if self.pending_in.get() {
             // The previous packet has not yet been transmitted, reject the new one.
             false
@@ -252,12 +260,12 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> ClientCtapHID<'a, 'b, C> {
             buf.copy_from_slice(packet);
             self.tx_packet.set(buf);
             // Alert the controller that we now have data to send on the Interrupt IN endpoint.
-            self.controller().endpoint_resume_in(1);
+            self.controller().endpoint_resume_in(endpoint);
             true
         }
     }
 
-    pub fn receive_packet(&'a self) -> bool {
+    pub fn receive_packet(&'a self, _: usize) -> bool {
         if self.pending_out.get() {
             // The previous packet has not yet been received, reject the new one.
             false
@@ -266,11 +274,12 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> ClientCtapHID<'a, 'b, C> {
             // In case we reported Delay before, send the pending packet back to the client.
             // Otherwise, there's nothing to do, the controller will send us a packet_out when a
             // packet arrives.
-            if self.delayed_out.take() {
-                if self.send_packet_to_client() {
+            let endpoint = self.delayed_out.take();
+            if endpoint > 0 {
+                if self.send_packet_to_client(endpoint) {
                     // If that succeeds, alert the controller that we can now
                     // receive data on the Interrupt OUT endpoint.
-                    self.controller().endpoint_resume_out(1);
+                    self.controller().endpoint_resume_out(endpoint);
                 }
             }
             true
@@ -280,14 +289,19 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> ClientCtapHID<'a, 'b, C> {
     // Send an OUT packet available in the controller back to the client.
     // This returns false if the client is not ready to receive a packet, and true if the client
     // successfully accepted the packet.
-    fn send_packet_to_client(&'a self) -> bool {
+    fn send_packet_to_client(&'a self, endpoint: usize  ) -> bool {
         // Copy the packet into a buffer to send to the client.
         let mut buf: [u8; 64] = [0; 64];
-        for (i, x) in self.out_buffer.buf.iter().enumerate() {
+        let from_buf:&Buffer64  = match endpoint {
+            1 => &self.out_buffer,
+            2 => &self.vendor_out_buffer,
+            _ => return false,
+        };
+        for (i, x) in from_buf.buf.iter().enumerate() {
             buf[i] = x.get();
         }
 
-        assert!(!self.delayed_out.get());
+        assert!(self.delayed_out.get() == 0);
 
         // Notify the client
         if self
@@ -301,11 +315,11 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> ClientCtapHID<'a, 'b, C> {
             // should be re-transmitted or not.
             self.cancel_in_transaction();
 
-            self.client.map(|client| client.packet_received(&buf));
+            self.client.map(|client| client.packet_received(&buf, endpoint));
             true
         } else {
             // Cannot receive now, indicate a delay to the controller.
-            self.delayed_out.set(true);
+            self.delayed_out.set(endpoint);
             false
         }
     }
@@ -341,6 +355,13 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> hil::usb::Client<'a> for ClientCtap
             .endpoint_set_out_buffer(1, &self.out_buffer.buf);
         self.controller()
             .endpoint_in_out_enable(TransferType::Interrupt, 1);
+        // Set up the vendor in-out endpoint
+        self.controller()
+            .endpoint_set_in_buffer(2, &self.vendor_in_buffer.buf);
+        self.controller()
+            .endpoint_set_out_buffer(2, &self.vendor_out_buffer.buf);
+        self.controller()
+            .endpoint_in_out_enable(TransferType::Interrupt, 2);
     }
 
     fn attach(&'a self) {
@@ -383,14 +404,15 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> hil::usb::Client<'a> for ClientCtap
         match transfer_type {
             TransferType::Bulk => hil::usb::InResult::Error,
             TransferType::Interrupt => {
-                if endpoint != 1 {
-                    return hil::usb::InResult::Error;
-                }
+                let buf:&Buffer64  = match endpoint {
+                    1 => &self.in_buffer,
+                    2 => &self.vendor_in_buffer,
+                    _ => return hil::usb::InResult::Error,
+                };
 
                 if let Some(packet) = self.tx_packet.take() {
-                    let buf = &self.in_buffer.buf;
                     for i in 0..64 {
-                        buf[i].set(packet[i]);
+                        buf.buf[i].set(packet[i]);
                     }
 
                     hil::usb::InResult::Packet(64)
@@ -413,7 +435,7 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> hil::usb::Client<'a> for ClientCtap
         match transfer_type {
             TransferType::Bulk => hil::usb::OutResult::Error,
             TransferType::Interrupt => {
-                if endpoint != 1 {
+                if endpoint > 2 {
                     return hil::usb::OutResult::Error;
                 }
 
@@ -421,7 +443,7 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> hil::usb::Client<'a> for ClientCtap
                     // Cannot process this packet
                     hil::usb::OutResult::Error
                 } else {
-                    if self.send_packet_to_client() {
+                    if self.send_packet_to_client(endpoint) {
                         hil::usb::OutResult::Ok
                     } else {
                         hil::usb::OutResult::Delay
@@ -433,7 +455,7 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> hil::usb::Client<'a> for ClientCtap
     }
 
     fn packet_transmitted(&'a self, endpoint: usize) {
-        if endpoint != 1 {
+        if endpoint > 2 {
             panic!("Unexpected transmission on ep {}", endpoint);
         }
 
